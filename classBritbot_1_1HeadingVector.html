<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Britbot: Britbot.HeadingVector Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Britbot
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceBritbot.html">Britbot</a>      </li>
      <li class="navelem"><a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">Britbot.HeadingVector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Britbot::HeadingVector" -->
<p>This class accumulates direction over large number of turns we assume (0,0) is the left top corner of the screen and that.  
 <a href="classBritbot_1_1HeadingVector.html#details">More...</a></p>

<p><a href="classBritbot_1_1HeadingVector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a1de2b7e3e9d87a3c7a221c1115b6cd2a.html#a1de2b7e3e9d87a3c7a221c1115b6cd2a">HeadingVector</a> (Direction d=Direction.NOTHING)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor: takes a direction of the game and turns it into a vector.  <a href="#a1de2b7e3e9d87a3c7a221c1115b6cd2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_ad243295175f4726f1d951161e3e304e9.html#ad243295175f4726f1d951161e3e304e9">HeadingVector</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> toCopy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ad243295175f4726f1d951161e3e304e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_ab6ceff6b06ee50f39e95c9d8e1af60ad.html#ab6ceff6b06ee50f39e95c9d8e1af60ad">HeadingVector</a> (double x, double y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple assignment constructor.  <a href="#ab6ceff6b06ee50f39e95c9d8e1af60ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_aeb1b68af60c8084f2767dd64e071cc0d.html#aeb1b68af60c8084f2767dd64e071cc0d">GetHashCode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a unique-ish hascide for the instance.  <a href="#aeb1b68af60c8084f2767dd64e071cc0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_aca36b9e4ce5251be33b102ae114e7813.html#aca36b9e4ce5251be33b102ae114e7813">SetCoordinates</a> (double x=0, double y=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">regular set function for convenience sets both X and Y simultaneously  <a href="#aca36b9e4ce5251be33b102ae114e7813"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a9b8a838b37bdcd949a94f988fd4c74dc.html#a9b8a838b37bdcd949a94f988fd4c74dc">SetCoordinates</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the parameters of a given heading vector.  <a href="#a9b8a838b37bdcd949a94f988fd4c74dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a7fd717fbeb6e0106d3422c92e4ce1202.html#a7fd717fbeb6e0106d3422c92e4ce1202">adjustHeading</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> Dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">same as the previous function just used as a method  <a href="#a7fd717fbeb6e0106d3422c92e4ce1202"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a4234c5d7774380f84fe03f972242bec3.html#a4234c5d7774380f84fe03f972242bec3">adjustHeading</a> (Direction Dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">same as the previous function just gets a direction  <a href="#a4234c5d7774380f84fe03f972242bec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a95945a35fa2dd64c2166df71a651df75.html#a95945a35fa2dd64c2166df71a651df75">Orthogonal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a new vector perpendicular to the given one it simply rotates 90 degrees anti clockwise.  <a href="#a95945a35fa2dd64c2166df71a651df75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a566caa70189508f1df84bcf414446891.html#a566caa70189508f1df84bcf414446891">NormSquared</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the vector's length might be used to normalize vectors for some computation.  <a href="#a566caa70189508f1df84bcf414446891"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_ab9a1032df60de54330a4bac6ab1d4ed9.html#ab9a1032df60de54330a4bac6ab1d4ed9">Norm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the length of the vector (as a double) might be used to normalize vectors for some computation  <a href="#ab9a1032df60de54330a4bac6ab1d4ed9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a9a783cd39ea13c65a26df7cfbb947da2.html#a9a783cd39ea13c65a26df7cfbb947da2">Normalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new normalized vector  <a href="#a9a783cd39ea13c65a26df7cfbb947da2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_ac430069042241046a59459c3f2c7442a.html#ac430069042241046a59459c3f2c7442a">Norm1</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of X and Y meaning the duration of time of the calculation. this can be used as a creditability measure  <a href="#ac430069042241046a59459c3f2c7442a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a8e3ba8001c1e048aa6206f48e842244a.html#a8e3ba8001c1e048aa6206f48e842244a">ToString</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To string function...  <a href="#a8e3ba8001c1e048aa6206f48e842244a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_abdcb06da41186570a5dfb7943be5bd46.html#abdcb06da41186570a5dfb7943be5bd46">Equals</a> (object obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two objects are the same.  <a href="#abdcb06da41186570a5dfb7943be5bd46"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_ae5d9d56437512240f74c8f8058cd5cb8.html#ae5d9d56437512240f74c8f8058cd5cb8">operator*</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the dot product for two vectors used to check if angles are sharp or doll (if they are the correct terms)  <a href="#ae5d9d56437512240f74c8f8058cd5cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_acd8b7e365e7a7d5023c6a47d4c12662d.html#acd8b7e365e7a7d5023c6a47d4c12662d">adjustHeading</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">this static method updates the direction based on the new one if the new direction is not to far from the one given (up to 90 degrees) it simply adds to the previous count vector otherwise, we assume there was a change in course and so we start again  <a href="#acd8b7e365e7a7d5023c6a47d4c12662d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a7a79c371a3e4199e5777bda2739c8db9.html#a7a79c371a3e4199e5777bda2739c8db9">adjustHeading</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, Direction dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">same as the previous one just gets a direction insted of a heading vector  <a href="#a7a79c371a3e4199e5777bda2739c8db9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_ad3b0af7cfb8aea81f5c3d4673d3376c3.html#ad3b0af7cfb8aea81f5c3d4673d3376c3">CalcDifference</a> (Location source, Location target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the direction vector between two points.  <a href="#ad3b0af7cfb8aea81f5c3d4673d3376c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Location&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_af861a548acd4510654479191b0dd7c4e.html#af861a548acd4510654479191b0dd7c4e">AddvanceByVector</a> (Location loc, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">given your location and your heading this function calculates your new position after going with the vector. consider the bounderies of the game  <a href="#af861a548acd4510654479191b0dd7c4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_af6b9b7a1eaef9d2b5b0647fd8d3cd682.html#af6b9b7a1eaef9d2b5b0647fd8d3cd682">operator==</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a hash code for this instance. Should be use by system sorting and what not. ReSharper generated code.  <a href="#af6b9b7a1eaef9d2b5b0647fd8d3cd682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a585adf8e7609247d999d5a4552c29372.html#a585adf8e7609247d999d5a4552c29372">operator!=</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if two vectors are not the same: compares both entries  <a href="#a585adf8e7609247d999d5a4552c29372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_af59dd73ad7f7c950cf534e1be9619581.html#af59dd73ad7f7c950cf534e1be9619581">operator+</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">regular "algebraic" sum of two vectors  <a href="#af59dd73ad7f7c950cf534e1be9619581"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a1538efc9a890f23d0bf0a68b4f4ed41d.html#a1538efc9a890f23d0bf0a68b4f4ed41d">operator-</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv1, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">regular "algebraic" difference between two vectors  <a href="#a1538efc9a890f23d0bf0a68b4f4ed41d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_a65591d044ac8584d4edcfab7c2aaadef.html#a65591d044ac8584d4edcfab7c2aaadef">operator*</a> (double scalar, <a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> hv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">just scalar multipication  <a href="#a65591d044ac8584d4edcfab7c2aaadef"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_aeb9faae4437756f51a0e275dc8858d41.html#aeb9faae4437756f51a0e275dc8858d41">Equals</a> (<a class="el" href="classBritbot_1_1HeadingVector.html">HeadingVector</a> other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the location determined by the direction if this heading vector and the pivot supplied.  <a href="#aeb9faae4437756f51a0e275dc8858d41"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_add4538f2b5a6d65e893dfb010ca3500f.html#add4538f2b5a6d65e893dfb010ca3500f">X</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive X value means left and vice-versa.  <a href="#add4538f2b5a6d65e893dfb010ca3500f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBritbot_1_1HeadingVector_abfc4aba249d23331ab25f043067ecc36.html#abfc4aba249d23331ab25f043067ecc36">Y</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive Y value means down and vice-versa.  <a href="#abfc4aba249d23331ab25f043067ecc36"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class accumulates direction over large number of turns we assume (0,0) is the left top corner of the screen and that. </p>

<p>Definition at line <a class="el" href="HeadingVector_8cs_source.html#l00014">14</a> of file <a class="el" href="HeadingVector_8cs_source.html">HeadingVector.cs</a>.</p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="HeadingVector_8cs_source.html">HeadingVector.cs</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 25 2015 17:05:07 for Britbot by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
